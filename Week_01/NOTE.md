# 学习笔记
# 栈和队列的实现与特性
 ## stck 栈
 1. FILO
 2. 添加 O1
 3. 删除 O1
 
## queue 队列
1. FIFO
 2. 添加 O1
 3. 删除 O1

## deque 双端队列
 2. 添加 O1
 3. 删除 O1

## priority queue 优先队列
1. 插入 O1
2. 取出 OlogN 
3. 底层实现多样，例如 heap、bst（二叉搜索树）、rbt、avl

# 作业
分析优先队列的源码

# 视频
1. 1.5~2倍速
2. 难点多遍+暂停

# 摈弃旧习惯
1. 不要死磕
2. 五毒神掌
    1. 5分钟有思路，10分钟完成第一遍，否则直接看答案
    2. 看最热门前3个答案，自己编写一次，复盘
    3. 第二天，回顾，再写一遍
    4. 一周后，回顾，再写一遍
    5. 面试/考试前，回顾，重点的再写一遍
3. 常见问题
    1. 死磕
    2. *只过一遍* 最大误区
    3. 没有反馈

# 电脑设置
1. 搜索引擎 google
2.  terminal
    1.  mac: iTerm2 + zsh
    2.  windows: Microsoft new terminal
        1.  [https://github.com/microsoft/terminal](https://github.com/microsoft/terminal)
        
# 尝试用信息的角度理解时间复杂度
1. 算法可以理解为收集信息作出决策的一个过程
    1. 例如，从64个有序的数字组成的数组中找到最小值，那么我们需要的信息量是6比特；
    2. 如果遍历这个数组，最糟糕的情况需要找64次。可以理解是每次查找获取的信息少于1比特；
    3. 最理想的情况是是二分查找，那么每次查询计算获取的信息是1比特；
    4. 算法的优化过程就能看成是去除冗余的过程；
    5. 也可以看成信息压缩的过程；
    6. 提取重用方法是不是可以看成用哈弗曼编码的思想压缩的过程。